package graphene.core

import scala.collection.mutable
import Graph._

class Graph[N](val endpoints: Endpoints[N], val rules: List[Rule[N]]) extends Function1[N, Set[Edge[N]]] {
  def rule(r: Rule[N]) = Graph(endpoints, rules :+ r)  // Add a new rule to this graph

  /**
   * Generate the set of edges from a node based on the rules.
   * Apply each rule in order, transforming the output of the previous rules.
   */
  override def apply(n: N): Set[Edge[N]] =
    rules.foldLeft(Set[Edge[N]]()) {(edges, r) => if (r.isDefinedAt(n, this, edges)) r(n, this, edges) else edges}

  /** Nodes connected to the `head` - directly or indirectly. */
  def nodes(): Set[N] = edges().flatMap(e => Set(e.source, e.destination))

  /** Edges of the nodes connected to `head`. */
  def edges(n: N = endpoints(HEAD)): Set[Edge[N]] = {
    val ex = apply(n)
    ex ++ ex.flatMap(e => edges(e.destination))
  }

  /** Tests whether the given node is a given endpoint. */
  def is(name: String, node: N): Boolean =
    endpoints.get(name).map(_ == node).getOrElse(false)
    
  /** Serializes this graph to a GEXF format for Gephi (https://gephi.org/gexf/format/). */
  def toXml: xml.Node = {
    def genColor(node: N, endpointName: String, color: (Int, Int, Int)) =
      {if (endpoints.get(endpointName).map(_ == node).getOrElse(false)) <viz:color r={color._1.toString} g={color._2.toString} b={color._3.toString} a="0.6"/>}

    <gexf xmlns="http://www.gexf.net/1.2draft" xmlns:viz="http://www.gexf.net/1.1draft/viz" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd" version="1.2">
      <graph defaultedgetype="directed">
        <nodes>
          {nodes().map {n =>
            <node id={n.hashCode.toString} label={n.toString}>51, 204, 51
              {genColor(n, HEAD   , (230, 230, 0 ))}  // Head is Yellow
              {genColor(n, SUCCESS, (51 , 204, 51))}  // Success is Green
              {genColor(n, FAILURE, (255, 51 , 0 ))}  // Failure is Red
            </node>
          }}
        </nodes>
        <edges>
          {edges().map {case e @ Edge(source, destination) =>
            <edge id={e.hashCode.toString} source={source.hashCode.toString} target={destination.hashCode.toString}/>
          }}
        </edges>
      </graph>
    </gexf>
  }

  /** Saves this graph as a GEXF to a given file, so that we can open it in Gephi to visualize. */
  def serialize(file: java.io.File) = graphene.util.IO.save(toXml.toString, file)
}

object Graph {
  type Endpoints[N] = Map[String, N]  // Nodes used to interact with the graph
  type Rule     [N] = PartialFunction[(N, Graph[N], Set[Edge[N]]), Set[Edge[N]]]  // Transforms edges that were generated by the previous rules to the new set of edges

  // Some useful endpoints
  val HEAD    = "head"
  val SUCCESS = "success"
  val FAILURE = "failure"

  /** To build edges like `2 ~ 3`. */
  implicit class EdgeBuilder[N](n: N) {
    def ~(n2: N): Edge[N] = Edge(n, n2)
  }

  /** Create a graph based on the rules. */
  def apply[N](endpoints: Endpoints[N], rules: List[Rule[N]]) = new Graph(endpoints, rules)

  /** Create a graph based on the edge set. */
  def apply[N](endpoints: Endpoints[N], edges: Edge[N]*): Graph[N] =
    edges.foldLeft(new Graph[N](endpoints, Nil))
      {(g, e) => g.rule {case (e.source, _, edges) => edges ++ Set(e)}}  // Writing the rules for the edges
      .rule {case (n, g, e) if g.is(HEAD, n) => e ++ Set(n ~ edges.head.source)} // Connect HEAD to the source of the first edge - so that it is available from the head.

}